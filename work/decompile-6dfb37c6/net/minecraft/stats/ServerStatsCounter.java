package net.minecraft.stats;

import com.google.common.collect.Sets;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonIOException;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.mojang.datafixers.DataFixer;
import com.mojang.logging.LogUtils;
import com.mojang.serialization.Codec;
import com.mojang.serialization.DataResult;
import com.mojang.serialization.Dynamic;
import com.mojang.serialization.JsonOps;
import it.unimi.dsi.fastutil.objects.Object2IntMap;
import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import net.minecraft.SharedConstants;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.nbt.NbtUtils;
import net.minecraft.network.protocol.game.ClientboundAwardStatsPacket;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.util.FileUtil;
import net.minecraft.util.StrictJsonParser;
import net.minecraft.util.Util;
import net.minecraft.util.datafix.DataFixTypes;
import net.minecraft.world.entity.player.Player;
import org.slf4j.Logger;

public class ServerStatsCounter extends StatsCounter {

    private static final Gson GSON = (new GsonBuilder()).setPrettyPrinting().create();
    private static final Logger LOGGER = LogUtils.getLogger();
    private static final Codec<Map<Stat<?>, Integer>> STATS_CODEC = Codec.dispatchedMap(BuiltInRegistries.STAT_TYPE.byNameCodec(), Util.memoize(ServerStatsCounter::createTypedStatsCodec)).xmap((map) -> {
        Map<Stat<?>, Integer> map1 = new HashMap();

        map.forEach((stattype, map2) -> {
            map1.putAll(map2);
        });
        return map1;
    }, (map) -> {
        return (Map) map.entrySet().stream().collect(Collectors.groupingBy((entry) -> {
            return ((Stat) entry.getKey()).getType();
        }, Util.toMap()));
    });
    private final Path file;
    private final Set<Stat<?>> dirty = Sets.newHashSet();

    private static <T> Codec<Map<Stat<?>, Integer>> createTypedStatsCodec(StatType<T> type) {
        Codec<T> codec = type.getRegistry().byNameCodec();

        Objects.requireNonNull(type);
        Codec<Stat<?>> codec1 = codec.flatComapMap(type::get, (stat) -> {
            return stat.getType() == type ? DataResult.success(stat.getValue()) : DataResult.error(() -> {
                String s = String.valueOf(type);

                return "Expected type " + s + ", but got " + String.valueOf(stat.getType());
            });
        });

        return Codec.unboundedMap(codec1, Codec.INT);
    }

    public ServerStatsCounter(MinecraftServer server, Path file) {
        this.file = file;
        if (Files.isRegularFile(file, new LinkOption[0])) {
            try (Reader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {
                JsonElement jsonelement = StrictJsonParser.parse(reader);

                this.parse(server.getFixerUpper(), jsonelement);
            } catch (IOException ioexception) {
                ServerStatsCounter.LOGGER.error("Couldn't read statistics file {}", file, ioexception);
            } catch (JsonParseException jsonparseexception) {
                ServerStatsCounter.LOGGER.error("Couldn't parse statistics file {}", file, jsonparseexception);
            }
        }

    }

    public void save() {
        try {
            FileUtil.createDirectoriesSafe(this.file.getParent());

            try (Writer writer = Files.newBufferedWriter(this.file, StandardCharsets.UTF_8)) {
                ServerStatsCounter.GSON.toJson(this.toJson(), ServerStatsCounter.GSON.newJsonWriter(writer));
            }
        } catch (JsonIOException | IOException ioexception) {
            ServerStatsCounter.LOGGER.error("Couldn't save stats to {}", this.file, ioexception);
        }

    }

    @Override
    public void setValue(Player player, Stat<?> stat, int count) {
        super.setValue(player, stat, count);
        this.dirty.add(stat);
    }

    private Set<Stat<?>> getDirty() {
        Set<Stat<?>> set = Sets.newHashSet(this.dirty);

        this.dirty.clear();
        return set;
    }

    public void parse(DataFixer fixerUpper, JsonElement element) {
        Dynamic<JsonElement> dynamic = new Dynamic(JsonOps.INSTANCE, element);

        dynamic = DataFixTypes.STATS.updateToCurrentVersion(fixerUpper, dynamic, NbtUtils.getDataVersion(dynamic, 1343));
        this.stats.putAll((Map) ServerStatsCounter.STATS_CODEC.parse(dynamic.get("stats").orElseEmptyMap()).resultOrPartial((s) -> {
            ServerStatsCounter.LOGGER.error("Failed to parse statistics for {}: {}", this.file, s);
        }).orElse(Map.of()));
    }

    protected JsonElement toJson() {
        JsonObject jsonobject = new JsonObject();

        jsonobject.add("stats", (JsonElement) ServerStatsCounter.STATS_CODEC.encodeStart(JsonOps.INSTANCE, this.stats).getOrThrow());
        jsonobject.addProperty("DataVersion", SharedConstants.getCurrentVersion().dataVersion().version());
        return jsonobject;
    }

    public void markAllDirty() {
        this.dirty.addAll(this.stats.keySet());
    }

    public void sendStats(ServerPlayer player) {
        Object2IntMap<Stat<?>> object2intmap = new Object2IntOpenHashMap();

        for (Stat<?> stat : this.getDirty()) {
            object2intmap.put(stat, this.getValue(stat));
        }

        player.connection.send(new ClientboundAwardStatsPacket(object2intmap));
    }
}
