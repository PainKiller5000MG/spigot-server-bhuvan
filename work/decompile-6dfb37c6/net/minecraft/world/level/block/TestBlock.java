package net.minecraft.world.level.block;

import com.mojang.serialization.MapCodec;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.core.component.DataComponents;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.util.RandomSource;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.component.BlockItemStateProperties;
import net.minecraft.world.item.context.BlockPlaceContext;
import net.minecraft.world.level.BlockGetter;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.LevelReader;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.entity.TestBlockEntity;
import net.minecraft.world.level.block.state.BlockBehaviour;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.StateDefinition;
import net.minecraft.world.level.block.state.properties.BlockStateProperties;
import net.minecraft.world.level.block.state.properties.EnumProperty;
import net.minecraft.world.level.block.state.properties.TestBlockMode;
import net.minecraft.world.level.redstone.Orientation;
import net.minecraft.world.phys.BlockHitResult;
import org.jspecify.annotations.Nullable;

public class TestBlock extends BaseEntityBlock implements GameMasterBlock {

    public static final MapCodec<TestBlock> CODEC = simpleCodec(TestBlock::new);
    public static final EnumProperty<TestBlockMode> MODE = BlockStateProperties.TEST_BLOCK_MODE;

    public TestBlock(BlockBehaviour.Properties properties) {
        super(properties);
    }

    @Override
    public @Nullable BlockEntity newBlockEntity(BlockPos worldPosition, BlockState blockState) {
        return new TestBlockEntity(worldPosition, blockState);
    }

    @Override
    public BlockState getStateForPlacement(BlockPlaceContext context) {
        BlockItemStateProperties blockitemstateproperties = (BlockItemStateProperties) context.getItemInHand().get(DataComponents.BLOCK_STATE);
        BlockState blockstate = this.defaultBlockState();

        if (blockitemstateproperties != null) {
            TestBlockMode testblockmode = (TestBlockMode) blockitemstateproperties.get(TestBlock.MODE);

            if (testblockmode != null) {
                blockstate = (BlockState) blockstate.setValue(TestBlock.MODE, testblockmode);
            }
        }

        return blockstate;
    }

    @Override
    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
        builder.add(TestBlock.MODE);
    }

    @Override
    protected InteractionResult useWithoutItem(BlockState state, Level level, BlockPos pos, Player player, BlockHitResult hitResult) {
        BlockEntity blockentity = level.getBlockEntity(pos);

        if (blockentity instanceof TestBlockEntity testblockentity) {
            if (!player.canUseGameMasterBlocks()) {
                return InteractionResult.PASS;
            } else {
                if (level.isClientSide()) {
                    player.openTestBlock(testblockentity);
                }

                return InteractionResult.SUCCESS;
            }
        } else {
            return InteractionResult.PASS;
        }
    }

    @Override
    protected void tick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
        TestBlockEntity testblockentity = getServerTestBlockEntity(level, pos);

        if (testblockentity != null) {
            testblockentity.reset();
        }
    }

    @Override
    protected void neighborChanged(BlockState state, Level level, BlockPos pos, Block block, @Nullable Orientation orientation, boolean movedByPiston) {
        TestBlockEntity testblockentity = getServerTestBlockEntity(level, pos);

        if (testblockentity != null) {
            if (testblockentity.getMode() != TestBlockMode.START) {
                boolean flag1 = level.hasNeighborSignal(pos);
                boolean flag2 = testblockentity.isPowered();

                if (flag1 && !flag2) {
                    testblockentity.setPowered(true);
                    testblockentity.trigger();
                } else if (!flag1 && flag2) {
                    testblockentity.setPowered(false);
                }

            }
        }
    }

    private static @Nullable TestBlockEntity getServerTestBlockEntity(Level level, BlockPos pos) {
        if (level instanceof ServerLevel serverlevel) {
            BlockEntity blockentity = serverlevel.getBlockEntity(pos);

            if (blockentity instanceof TestBlockEntity testblockentity) {
                return testblockentity;
            }
        }

        return null;
    }

    @Override
    public int getSignal(BlockState state, BlockGetter level, BlockPos pos, Direction direction) {
        if (state.getValue(TestBlock.MODE) != TestBlockMode.START) {
            return 0;
        } else {
            BlockEntity blockentity = level.getBlockEntity(pos);

            if (blockentity instanceof TestBlockEntity) {
                TestBlockEntity testblockentity = (TestBlockEntity) blockentity;

                return testblockentity.isPowered() ? 15 : 0;
            } else {
                return 0;
            }
        }
    }

    @Override
    protected ItemStack getCloneItemStack(LevelReader level, BlockPos pos, BlockState state, boolean includeData) {
        ItemStack itemstack = super.getCloneItemStack(level, pos, state, includeData);

        return setModeOnStack(itemstack, (TestBlockMode) state.getValue(TestBlock.MODE));
    }

    public static ItemStack setModeOnStack(ItemStack itemStack, TestBlockMode mode) {
        itemStack.set(DataComponents.BLOCK_STATE, ((BlockItemStateProperties) itemStack.getOrDefault(DataComponents.BLOCK_STATE, BlockItemStateProperties.EMPTY)).with(TestBlock.MODE, mode));
        return itemStack;
    }

    @Override
    protected MapCodec<TestBlock> codec() {
        return TestBlock.CODEC;
    }
}
