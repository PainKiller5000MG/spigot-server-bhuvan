package net.minecraft.world.level.levelgen;

import com.mojang.datafixers.util.Either;
import com.mojang.logging.LogUtils;
import com.mojang.serialization.Codec;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import it.unimi.dsi.fastutil.doubles.Double2DoubleFunction;
import java.util.Arrays;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;
import net.minecraft.core.Holder;
import net.minecraft.core.Registry;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.resources.ResourceKey;
import net.minecraft.util.BoundedFloatFunction;
import net.minecraft.util.CubicSpline;
import net.minecraft.util.ExtraCodecs;
import net.minecraft.util.KeyDispatchDataCodec;
import net.minecraft.util.Mth;
import net.minecraft.util.RandomSource;
import net.minecraft.util.StringRepresentable;
import net.minecraft.util.VisibleForDebug;
import net.minecraft.world.level.dimension.DimensionType;
import net.minecraft.world.level.levelgen.synth.BlendedNoise;
import net.minecraft.world.level.levelgen.synth.NormalNoise;
import net.minecraft.world.level.levelgen.synth.SimplexNoise;
import org.slf4j.Logger;

public final class DensityFunctions {

    private static final Codec<DensityFunction> CODEC = BuiltInRegistries.DENSITY_FUNCTION_TYPE.byNameCodec().dispatch((densityfunction) -> {
        return densityfunction.codec().codec();
    }, Function.identity());
    protected static final double MAX_REASONABLE_NOISE_VALUE = 1000000.0D;
    private static final Codec<Double> NOISE_VALUE_CODEC = Codec.doubleRange(-1000000.0D, 1000000.0D);
    public static final Codec<DensityFunction> DIRECT_CODEC = Codec.either(DensityFunctions.NOISE_VALUE_CODEC, DensityFunctions.CODEC).xmap((either) -> {
        return (DensityFunction) either.map(DensityFunctions::constant, Function.identity());
    }, (densityfunction) -> {
        if (densityfunction instanceof DensityFunctions.Constant densityfunctions_constant) {
            return Either.left(densityfunctions_constant.value());
        } else {
            return Either.right(densityfunction);
        }
    });

    public static MapCodec<? extends DensityFunction> bootstrap(Registry<MapCodec<? extends DensityFunction>> registry) {
        register(registry, "blend_alpha", DensityFunctions.BlendAlpha.CODEC);
        register(registry, "blend_offset", DensityFunctions.BlendOffset.CODEC);
        register(registry, "beardifier", DensityFunctions.BeardifierMarker.CODEC);
        register(registry, "old_blended_noise", BlendedNoise.CODEC);

        for (DensityFunctions.Marker.Type densityfunctions_marker_type : DensityFunctions.Marker.Type.values()) {
            register(registry, densityfunctions_marker_type.getSerializedName(), densityfunctions_marker_type.codec);
        }

        register(registry, "noise", DensityFunctions.Noise.CODEC);
        register(registry, "end_islands", DensityFunctions.EndIslandDensityFunction.CODEC);
        register(registry, "weird_scaled_sampler", DensityFunctions.WeirdScaledSampler.CODEC);
        register(registry, "shifted_noise", DensityFunctions.ShiftedNoise.CODEC);
        register(registry, "range_choice", DensityFunctions.RangeChoice.CODEC);
        register(registry, "shift_a", DensityFunctions.ShiftA.CODEC);
        register(registry, "shift_b", DensityFunctions.ShiftB.CODEC);
        register(registry, "shift", DensityFunctions.Shift.CODEC);
        register(registry, "blend_density", DensityFunctions.BlendDensity.CODEC);
        register(registry, "clamp", DensityFunctions.Clamp.CODEC);

        for (DensityFunctions.Mapped.Type densityfunctions_mapped_type : DensityFunctions.Mapped.Type.values()) {
            register(registry, densityfunctions_mapped_type.getSerializedName(), densityfunctions_mapped_type.codec);
        }

        for (DensityFunctions.TwoArgumentSimpleFunction.Type densityfunctions_twoargumentsimplefunction_type : DensityFunctions.TwoArgumentSimpleFunction.Type.values()) {
            register(registry, densityfunctions_twoargumentsimplefunction_type.getSerializedName(), densityfunctions_twoargumentsimplefunction_type.codec);
        }

        register(registry, "spline", DensityFunctions.Spline.CODEC);
        register(registry, "constant", DensityFunctions.Constant.CODEC);
        register(registry, "y_clamped_gradient", DensityFunctions.YClampedGradient.CODEC);
        return register(registry, "find_top_surface", DensityFunctions.FindTopSurface.CODEC);
    }

    private static MapCodec<? extends DensityFunction> register(Registry<MapCodec<? extends DensityFunction>> registry, String name, KeyDispatchDataCodec<? extends DensityFunction> codec) {
        return (MapCodec) Registry.register(registry, name, codec.codec());
    }

    private static <A, O> KeyDispatchDataCodec<O> singleArgumentCodec(Codec<A> argumentCodec, Function<A, O> constructor, Function<O, A> getter) {
        return KeyDispatchDataCodec.<O>of(argumentCodec.fieldOf("argument").xmap(constructor, getter));
    }

    private static <O> KeyDispatchDataCodec<O> singleFunctionArgumentCodec(Function<DensityFunction, O> constructor, Function<O, DensityFunction> getter) {
        return singleArgumentCodec(DensityFunction.HOLDER_HELPER_CODEC, constructor, getter);
    }

    private static <O> KeyDispatchDataCodec<O> doubleFunctionArgumentCodec(BiFunction<DensityFunction, DensityFunction, O> constructor, Function<O, DensityFunction> firstArgumentGetter, Function<O, DensityFunction> secondArgumentGetter) {
        return KeyDispatchDataCodec.<O>of(RecordCodecBuilder.mapCodec((instance) -> {
            return instance.group(DensityFunction.HOLDER_HELPER_CODEC.fieldOf("argument1").forGetter(firstArgumentGetter), DensityFunction.HOLDER_HELPER_CODEC.fieldOf("argument2").forGetter(secondArgumentGetter)).apply(instance, constructor);
        }));
    }

    private static <O> KeyDispatchDataCodec<O> makeCodec(MapCodec<O> dataCodec) {
        return KeyDispatchDataCodec.<O>of(dataCodec);
    }

    private DensityFunctions() {}

    public static DensityFunction interpolated(DensityFunction function) {
        return new DensityFunctions.Marker(DensityFunctions.Marker.Type.Interpolated, function);
    }

    public static DensityFunction flatCache(DensityFunction function) {
        return new DensityFunctions.Marker(DensityFunctions.Marker.Type.FlatCache, function);
    }

    public static DensityFunction cache2d(DensityFunction function) {
        return new DensityFunctions.Marker(DensityFunctions.Marker.Type.Cache2D, function);
    }

    public static DensityFunction cacheOnce(DensityFunction function) {
        return new DensityFunctions.Marker(DensityFunctions.Marker.Type.CacheOnce, function);
    }

    public static DensityFunction cacheAllInCell(DensityFunction function) {
        return new DensityFunctions.Marker(DensityFunctions.Marker.Type.CacheAllInCell, function);
    }

    public static DensityFunction mappedNoise(Holder<NormalNoise.NoiseParameters> noiseData, @Deprecated double xzScale, double yScale, double minTarget, double maxTarget) {
        return mapFromUnitTo(new DensityFunctions.Noise(new DensityFunction.NoiseHolder(noiseData), xzScale, yScale), minTarget, maxTarget);
    }

    public static DensityFunction mappedNoise(Holder<NormalNoise.NoiseParameters> noiseData, double yScale, double minTarget, double maxTarget) {
        return mappedNoise(noiseData, 1.0D, yScale, minTarget, maxTarget);
    }

    public static DensityFunction mappedNoise(Holder<NormalNoise.NoiseParameters> noiseData, double minTarget, double maxTarget) {
        return mappedNoise(noiseData, 1.0D, 1.0D, minTarget, maxTarget);
    }

    public static DensityFunction shiftedNoise2d(DensityFunction shiftX, DensityFunction shiftZ, double xzScale, Holder<NormalNoise.NoiseParameters> noiseData) {
        return new DensityFunctions.ShiftedNoise(shiftX, zero(), shiftZ, xzScale, 0.0D, new DensityFunction.NoiseHolder(noiseData));
    }

    public static DensityFunction noise(Holder<NormalNoise.NoiseParameters> noiseData) {
        return noise(noiseData, 1.0D, 1.0D);
    }

    public static DensityFunction noise(Holder<NormalNoise.NoiseParameters> noiseData, double xzScale, double yScale) {
        return new DensityFunctions.Noise(new DensityFunction.NoiseHolder(noiseData), xzScale, yScale);
    }

    public static DensityFunction noise(Holder<NormalNoise.NoiseParameters> noiseData, double yScale) {
        return noise(noiseData, 1.0D, yScale);
    }

    public static DensityFunction rangeChoice(DensityFunction input, double minInclusive, double maxExclusive, DensityFunction whenInRange, DensityFunction whenOutOfRange) {
        return new DensityFunctions.RangeChoice(input, minInclusive, maxExclusive, whenInRange, whenOutOfRange);
    }

    public static DensityFunction shiftA(Holder<NormalNoise.NoiseParameters> noiseData) {
        return new DensityFunctions.ShiftA(new DensityFunction.NoiseHolder(noiseData));
    }

    public static DensityFunction shiftB(Holder<NormalNoise.NoiseParameters> noiseData) {
        return new DensityFunctions.ShiftB(new DensityFunction.NoiseHolder(noiseData));
    }

    public static DensityFunction shift(Holder<NormalNoise.NoiseParameters> noiseData) {
        return new DensityFunctions.Shift(new DensityFunction.NoiseHolder(noiseData));
    }

    public static DensityFunction blendDensity(DensityFunction input) {
        return new DensityFunctions.BlendDensity(input);
    }

    public static DensityFunction endIslands(long seed) {
        return new DensityFunctions.EndIslandDensityFunction(seed);
    }

    public static DensityFunction weirdScaledSampler(DensityFunction input, Holder<NormalNoise.NoiseParameters> noiseData, DensityFunctions.WeirdScaledSampler.RarityValueMapper rarityValueMapper) {
        return new DensityFunctions.WeirdScaledSampler(input, new DensityFunction.NoiseHolder(noiseData), rarityValueMapper);
    }

    public static DensityFunction add(DensityFunction f1, DensityFunction f2) {
        return DensityFunctions.TwoArgumentSimpleFunction.create(DensityFunctions.TwoArgumentSimpleFunction.Type.ADD, f1, f2);
    }

    public static DensityFunction mul(DensityFunction f1, DensityFunction f2) {
        return DensityFunctions.TwoArgumentSimpleFunction.create(DensityFunctions.TwoArgumentSimpleFunction.Type.MUL, f1, f2);
    }

    public static DensityFunction min(DensityFunction f1, DensityFunction f2) {
        return DensityFunctions.TwoArgumentSimpleFunction.create(DensityFunctions.TwoArgumentSimpleFunction.Type.MIN, f1, f2);
    }

    public static DensityFunction max(DensityFunction f1, DensityFunction f2) {
        return DensityFunctions.TwoArgumentSimpleFunction.create(DensityFunctions.TwoArgumentSimpleFunction.Type.MAX, f1, f2);
    }

    public static DensityFunction spline(CubicSpline<DensityFunctions.Spline.Point, DensityFunctions.Spline.Coordinate> spline) {
        return new DensityFunctions.Spline(spline);
    }

    public static DensityFunction zero() {
        return DensityFunctions.Constant.ZERO;
    }

    public static DensityFunction constant(double value) {
        return new DensityFunctions.Constant(value);
    }

    public static DensityFunction yClampedGradient(int fromY, int toY, double fromValue, double toValue) {
        return new DensityFunctions.YClampedGradient(fromY, toY, fromValue, toValue);
    }

    public static DensityFunction map(DensityFunction function, DensityFunctions.Mapped.Type type) {
        return DensityFunctions.Mapped.create(type, function);
    }

    private static DensityFunction mapFromUnitTo(DensityFunction function, double min, double max) {
        double d2 = (min + max) * 0.5D;
        double d3 = (max - min) * 0.5D;

        return add(constant(d2), mul(constant(d3), function));
    }

    public static DensityFunction blendAlpha() {
        return DensityFunctions.BlendAlpha.INSTANCE;
    }

    public static DensityFunction blendOffset() {
        return DensityFunctions.BlendOffset.INSTANCE;
    }

    public static DensityFunction lerp(DensityFunction alpha, DensityFunction first, DensityFunction second) {
        if (first instanceof DensityFunctions.Constant densityfunctions_constant) {
            return lerp(alpha, densityfunctions_constant.value, second);
        } else {
            DensityFunction densityfunction3 = cacheOnce(alpha);
            DensityFunction densityfunction4 = add(mul(densityfunction3, constant(-1.0D)), constant(1.0D));

            return add(mul(first, densityfunction4), mul(second, densityfunction3));
        }
    }

    public static DensityFunction lerp(DensityFunction factor, double first, DensityFunction second) {
        return add(mul(factor, add(second, constant(-first))), constant(first));
    }

    public static DensityFunction findTopSurface(DensityFunction density, DensityFunction upperBound, int lowerBound, int stepSize) {
        return new DensityFunctions.FindTopSurface(density, upperBound, lowerBound, stepSize);
    }

    private interface TransformerWithContext extends DensityFunction {

        DensityFunction input();

        @Override
        default double compute(DensityFunction.FunctionContext context) {
            return this.transform(context, this.input().compute(context));
        }

        @Override
        default void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            this.input().fillArray(output, contextProvider);

            for (int i = 0; i < output.length; ++i) {
                output[i] = this.transform(contextProvider.forIndex(i), output[i]);
            }

        }

        double transform(DensityFunction.FunctionContext contextSupplier, double input);
    }

    private interface PureTransformer extends DensityFunction {

        DensityFunction input();

        @Override
        default double compute(DensityFunction.FunctionContext context) {
            return this.transform(this.input().compute(context));
        }

        @Override
        default void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            this.input().fillArray(output, contextProvider);

            for (int i = 0; i < output.length; ++i) {
                output[i] = this.transform(output[i]);
            }

        }

        double transform(double input);
    }

    protected static enum BlendAlpha implements DensityFunction.SimpleFunction {

        INSTANCE;

        public static final KeyDispatchDataCodec<DensityFunction> CODEC = KeyDispatchDataCodec.<DensityFunction>of(MapCodec.unit(DensityFunctions.BlendAlpha.INSTANCE));

        private BlendAlpha() {}

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return 1.0D;
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            Arrays.fill(output, 1.0D);
        }

        @Override
        public double minValue() {
            return 1.0D;
        }

        @Override
        public double maxValue() {
            return 1.0D;
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.BlendAlpha.CODEC;
        }
    }

    protected static enum BlendOffset implements DensityFunction.SimpleFunction {

        INSTANCE;

        public static final KeyDispatchDataCodec<DensityFunction> CODEC = KeyDispatchDataCodec.<DensityFunction>of(MapCodec.unit(DensityFunctions.BlendOffset.INSTANCE));

        private BlendOffset() {}

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return 0.0D;
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            Arrays.fill(output, 0.0D);
        }

        @Override
        public double minValue() {
            return 0.0D;
        }

        @Override
        public double maxValue() {
            return 0.0D;
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.BlendOffset.CODEC;
        }
    }

    public interface BeardifierOrMarker extends DensityFunction.SimpleFunction {

        KeyDispatchDataCodec<DensityFunction> CODEC = KeyDispatchDataCodec.<DensityFunction>of(MapCodec.unit(DensityFunctions.BeardifierMarker.INSTANCE));

        @Override
        default KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.BeardifierOrMarker.CODEC;
        }
    }

    protected static enum BeardifierMarker implements DensityFunctions.BeardifierOrMarker {

        INSTANCE;

        private BeardifierMarker() {}

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return 0.0D;
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            Arrays.fill(output, 0.0D);
        }

        @Override
        public double minValue() {
            return 0.0D;
        }

        @Override
        public double maxValue() {
            return 0.0D;
        }
    }

    @VisibleForDebug
    public static record HolderHolder(Holder<DensityFunction> function) implements DensityFunction {

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return ((DensityFunction) this.function.value()).compute(context);
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            ((DensityFunction) this.function.value()).fillArray(output, contextProvider);
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.HolderHolder(new Holder.Direct(((DensityFunction) this.function.value()).mapAll(visitor))));
        }

        @Override
        public double minValue() {
            return this.function.isBound() ? ((DensityFunction) this.function.value()).minValue() : Double.NEGATIVE_INFINITY;
        }

        @Override
        public double maxValue() {
            return this.function.isBound() ? ((DensityFunction) this.function.value()).maxValue() : Double.POSITIVE_INFINITY;
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            throw new UnsupportedOperationException("Calling .codec() on HolderHolder");
        }
    }

    public interface MarkerOrMarked extends DensityFunction {

        DensityFunctions.Marker.Type type();

        DensityFunction wrapped();

        @Override
        default KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return this.type().codec;
        }

        @Override
        default DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.Marker(this.type(), this.wrapped().mapAll(visitor)));
        }
    }

    protected static record Marker(DensityFunctions.Marker.Type type, DensityFunction wrapped) implements DensityFunctions.MarkerOrMarked {

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return this.wrapped.compute(context);
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            this.wrapped.fillArray(output, contextProvider);
        }

        @Override
        public double minValue() {
            return this.wrapped.minValue();
        }

        @Override
        public double maxValue() {
            return this.wrapped.maxValue();
        }

        static enum Type implements StringRepresentable {

            Interpolated("interpolated"), FlatCache("flat_cache"), Cache2D("cache_2d"), CacheOnce("cache_once"), CacheAllInCell("cache_all_in_cell");

            private final String name;
            private final KeyDispatchDataCodec<DensityFunctions.MarkerOrMarked> codec = DensityFunctions.<DensityFunctions.MarkerOrMarked>singleFunctionArgumentCodec((densityfunction) -> {
                return new DensityFunctions.Marker(this, densityfunction);
            }, DensityFunctions.MarkerOrMarked::wrapped);

            private Type(String name) {
                this.name = name;
            }

            @Override
            public String getSerializedName() {
                return this.name;
            }
        }
    }

    protected static record Noise(DensityFunction.NoiseHolder noise, double xzScale, double yScale) implements DensityFunction {

        public static final MapCodec<DensityFunctions.Noise> DATA_CODEC = RecordCodecBuilder.mapCodec((instance) -> {
            return instance.group(DensityFunction.NoiseHolder.CODEC.fieldOf("noise").forGetter(DensityFunctions.Noise::noise), Codec.DOUBLE.fieldOf("xz_scale").forGetter(DensityFunctions.Noise::xzScale), Codec.DOUBLE.fieldOf("y_scale").forGetter(DensityFunctions.Noise::yScale)).apply(instance, DensityFunctions.Noise::new);
        });
        public static final KeyDispatchDataCodec<DensityFunctions.Noise> CODEC = DensityFunctions.<DensityFunctions.Noise>makeCodec(DensityFunctions.Noise.DATA_CODEC);

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return this.noise.getValue((double) context.blockX() * this.xzScale, (double) context.blockY() * this.yScale, (double) context.blockZ() * this.xzScale);
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            contextProvider.fillAllDirectly(output, this);
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.Noise(visitor.visitNoise(this.noise), this.xzScale, this.yScale));
        }

        @Override
        public double minValue() {
            return -this.maxValue();
        }

        @Override
        public double maxValue() {
            return this.noise.maxValue();
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.Noise.CODEC;
        }

        /** @deprecated */
        @Deprecated
        public double xzScale() {
            return this.xzScale;
        }
    }

    protected static final class EndIslandDensityFunction implements DensityFunction.SimpleFunction {

        public static final KeyDispatchDataCodec<DensityFunctions.EndIslandDensityFunction> CODEC = KeyDispatchDataCodec.<DensityFunctions.EndIslandDensityFunction>of(MapCodec.unit(new DensityFunctions.EndIslandDensityFunction(0L)));
        private static final float ISLAND_THRESHOLD = -0.9F;
        private final SimplexNoise islandNoise;

        public EndIslandDensityFunction(long seed) {
            RandomSource randomsource = new LegacyRandomSource(seed);

            randomsource.consumeCount(17292);
            this.islandNoise = new SimplexNoise(randomsource);
        }

        private static float getHeightValue(SimplexNoise islandNoise, int sectionX, int sectionZ) {
            int k = sectionX / 2;
            int l = sectionZ / 2;
            int i1 = sectionX % 2;
            int j1 = sectionZ % 2;
            float f = 100.0F - Mth.sqrt((float) (sectionX * sectionX + sectionZ * sectionZ)) * 8.0F;

            f = Mth.clamp(f, -100.0F, 80.0F);

            for (int k1 = -12; k1 <= 12; ++k1) {
                for (int l1 = -12; l1 <= 12; ++l1) {
                    long i2 = (long) (k + k1);
                    long j2 = (long) (l + l1);

                    if (i2 * i2 + j2 * j2 > 4096L && islandNoise.getValue((double) i2, (double) j2) < (double) -0.9F) {
                        float f1 = (Mth.abs((float) i2) * 3439.0F + Mth.abs((float) j2) * 147.0F) % 13.0F + 9.0F;
                        float f2 = (float) (i1 - k1 * 2);
                        float f3 = (float) (j1 - l1 * 2);
                        float f4 = 100.0F - Mth.sqrt(f2 * f2 + f3 * f3) * f1;

                        f4 = Mth.clamp(f4, -100.0F, 80.0F);
                        f = Math.max(f, f4);
                    }
                }
            }

            return f;
        }

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return ((double) getHeightValue(this.islandNoise, context.blockX() / 8, context.blockZ() / 8) - 8.0D) / 128.0D;
        }

        @Override
        public double minValue() {
            return -0.84375D;
        }

        @Override
        public double maxValue() {
            return 0.5625D;
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.EndIslandDensityFunction.CODEC;
        }
    }

    protected static record WeirdScaledSampler(DensityFunction input, DensityFunction.NoiseHolder noise, DensityFunctions.WeirdScaledSampler.RarityValueMapper rarityValueMapper) implements DensityFunctions.TransformerWithContext {

        private static final MapCodec<DensityFunctions.WeirdScaledSampler> DATA_CODEC = RecordCodecBuilder.mapCodec((instance) -> {
            return instance.group(DensityFunction.HOLDER_HELPER_CODEC.fieldOf("input").forGetter(DensityFunctions.WeirdScaledSampler::input), DensityFunction.NoiseHolder.CODEC.fieldOf("noise").forGetter(DensityFunctions.WeirdScaledSampler::noise), DensityFunctions.WeirdScaledSampler.RarityValueMapper.CODEC.fieldOf("rarity_value_mapper").forGetter(DensityFunctions.WeirdScaledSampler::rarityValueMapper)).apply(instance, DensityFunctions.WeirdScaledSampler::new);
        });
        public static final KeyDispatchDataCodec<DensityFunctions.WeirdScaledSampler> CODEC = DensityFunctions.<DensityFunctions.WeirdScaledSampler>makeCodec(DensityFunctions.WeirdScaledSampler.DATA_CODEC);

        @Override
        public double transform(DensityFunction.FunctionContext context, double input) {
            double d1 = this.rarityValueMapper.mapper.get(input);

            return d1 * Math.abs(this.noise.getValue((double) context.blockX() / d1, (double) context.blockY() / d1, (double) context.blockZ() / d1));
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.WeirdScaledSampler(this.input.mapAll(visitor), visitor.visitNoise(this.noise), this.rarityValueMapper));
        }

        @Override
        public double minValue() {
            return 0.0D;
        }

        @Override
        public double maxValue() {
            return this.rarityValueMapper.maxRarity * this.noise.maxValue();
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.WeirdScaledSampler.CODEC;
        }

        public static enum RarityValueMapper implements StringRepresentable {

            TYPE1("type_1", NoiseRouterData.QuantizedSpaghettiRarity::getSpaghettiRarity3D, 2.0D), TYPE2("type_2", NoiseRouterData.QuantizedSpaghettiRarity::getSphaghettiRarity2D, 3.0D);

            public static final Codec<DensityFunctions.WeirdScaledSampler.RarityValueMapper> CODEC = StringRepresentable.<DensityFunctions.WeirdScaledSampler.RarityValueMapper>fromEnum(DensityFunctions.WeirdScaledSampler.RarityValueMapper::values);
            private final String name;
            private final Double2DoubleFunction mapper;
            private final double maxRarity;

            private RarityValueMapper(String name, Double2DoubleFunction mapper, double maxRarity) {
                this.name = name;
                this.mapper = mapper;
                this.maxRarity = maxRarity;
            }

            @Override
            public String getSerializedName() {
                return this.name;
            }
        }
    }

    protected static record ShiftedNoise(DensityFunction shiftX, DensityFunction shiftY, DensityFunction shiftZ, double xzScale, double yScale, DensityFunction.NoiseHolder noise) implements DensityFunction {

        private static final MapCodec<DensityFunctions.ShiftedNoise> DATA_CODEC = RecordCodecBuilder.mapCodec((instance) -> {
            return instance.group(DensityFunction.HOLDER_HELPER_CODEC.fieldOf("shift_x").forGetter(DensityFunctions.ShiftedNoise::shiftX), DensityFunction.HOLDER_HELPER_CODEC.fieldOf("shift_y").forGetter(DensityFunctions.ShiftedNoise::shiftY), DensityFunction.HOLDER_HELPER_CODEC.fieldOf("shift_z").forGetter(DensityFunctions.ShiftedNoise::shiftZ), Codec.DOUBLE.fieldOf("xz_scale").forGetter(DensityFunctions.ShiftedNoise::xzScale), Codec.DOUBLE.fieldOf("y_scale").forGetter(DensityFunctions.ShiftedNoise::yScale), DensityFunction.NoiseHolder.CODEC.fieldOf("noise").forGetter(DensityFunctions.ShiftedNoise::noise)).apply(instance, DensityFunctions.ShiftedNoise::new);
        });
        public static final KeyDispatchDataCodec<DensityFunctions.ShiftedNoise> CODEC = DensityFunctions.<DensityFunctions.ShiftedNoise>makeCodec(DensityFunctions.ShiftedNoise.DATA_CODEC);

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            double d0 = (double) context.blockX() * this.xzScale + this.shiftX.compute(context);
            double d1 = (double) context.blockY() * this.yScale + this.shiftY.compute(context);
            double d2 = (double) context.blockZ() * this.xzScale + this.shiftZ.compute(context);

            return this.noise.getValue(d0, d1, d2);
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            contextProvider.fillAllDirectly(output, this);
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.ShiftedNoise(this.shiftX.mapAll(visitor), this.shiftY.mapAll(visitor), this.shiftZ.mapAll(visitor), this.xzScale, this.yScale, visitor.visitNoise(this.noise)));
        }

        @Override
        public double minValue() {
            return -this.maxValue();
        }

        @Override
        public double maxValue() {
            return this.noise.maxValue();
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.ShiftedNoise.CODEC;
        }
    }

    private static record RangeChoice(DensityFunction input, double minInclusive, double maxExclusive, DensityFunction whenInRange, DensityFunction whenOutOfRange) implements DensityFunction {

        public static final MapCodec<DensityFunctions.RangeChoice> DATA_CODEC = RecordCodecBuilder.mapCodec((instance) -> {
            return instance.group(DensityFunction.HOLDER_HELPER_CODEC.fieldOf("input").forGetter(DensityFunctions.RangeChoice::input), DensityFunctions.NOISE_VALUE_CODEC.fieldOf("min_inclusive").forGetter(DensityFunctions.RangeChoice::minInclusive), DensityFunctions.NOISE_VALUE_CODEC.fieldOf("max_exclusive").forGetter(DensityFunctions.RangeChoice::maxExclusive), DensityFunction.HOLDER_HELPER_CODEC.fieldOf("when_in_range").forGetter(DensityFunctions.RangeChoice::whenInRange), DensityFunction.HOLDER_HELPER_CODEC.fieldOf("when_out_of_range").forGetter(DensityFunctions.RangeChoice::whenOutOfRange)).apply(instance, DensityFunctions.RangeChoice::new);
        });
        public static final KeyDispatchDataCodec<DensityFunctions.RangeChoice> CODEC = DensityFunctions.<DensityFunctions.RangeChoice>makeCodec(DensityFunctions.RangeChoice.DATA_CODEC);

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            double d0 = this.input.compute(context);

            return d0 >= this.minInclusive && d0 < this.maxExclusive ? this.whenInRange.compute(context) : this.whenOutOfRange.compute(context);
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            this.input.fillArray(output, contextProvider);

            for (int i = 0; i < output.length; ++i) {
                double d0 = output[i];

                if (d0 >= this.minInclusive && d0 < this.maxExclusive) {
                    output[i] = this.whenInRange.compute(contextProvider.forIndex(i));
                } else {
                    output[i] = this.whenOutOfRange.compute(contextProvider.forIndex(i));
                }
            }

        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.RangeChoice(this.input.mapAll(visitor), this.minInclusive, this.maxExclusive, this.whenInRange.mapAll(visitor), this.whenOutOfRange.mapAll(visitor)));
        }

        @Override
        public double minValue() {
            return Math.min(this.whenInRange.minValue(), this.whenOutOfRange.minValue());
        }

        @Override
        public double maxValue() {
            return Math.max(this.whenInRange.maxValue(), this.whenOutOfRange.maxValue());
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.RangeChoice.CODEC;
        }
    }

    interface ShiftNoise extends DensityFunction {

        DensityFunction.NoiseHolder offsetNoise();

        @Override
        default double minValue() {
            return -this.maxValue();
        }

        @Override
        default double maxValue() {
            return this.offsetNoise().maxValue() * 4.0D;
        }

        default double compute(double localX, double localY, double localZ) {
            return this.offsetNoise().getValue(localX * 0.25D, localY * 0.25D, localZ * 0.25D) * 4.0D;
        }

        @Override
        default void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            contextProvider.fillAllDirectly(output, this);
        }
    }

    protected static record ShiftA(DensityFunction.NoiseHolder offsetNoise) implements DensityFunctions.ShiftNoise {

        private static final KeyDispatchDataCodec<DensityFunctions.ShiftA> CODEC = DensityFunctions.singleArgumentCodec(DensityFunction.NoiseHolder.CODEC, DensityFunctions.ShiftA::new, DensityFunctions.ShiftA::offsetNoise);

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return this.compute((double) context.blockX(), 0.0D, (double) context.blockZ());
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.ShiftA(visitor.visitNoise(this.offsetNoise)));
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.ShiftA.CODEC;
        }
    }

    protected static record ShiftB(DensityFunction.NoiseHolder offsetNoise) implements DensityFunctions.ShiftNoise {

        private static final KeyDispatchDataCodec<DensityFunctions.ShiftB> CODEC = DensityFunctions.singleArgumentCodec(DensityFunction.NoiseHolder.CODEC, DensityFunctions.ShiftB::new, DensityFunctions.ShiftB::offsetNoise);

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return this.compute((double) context.blockZ(), (double) context.blockX(), 0.0D);
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.ShiftB(visitor.visitNoise(this.offsetNoise)));
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.ShiftB.CODEC;
        }
    }

    protected static record Shift(DensityFunction.NoiseHolder offsetNoise) implements DensityFunctions.ShiftNoise {

        private static final KeyDispatchDataCodec<DensityFunctions.Shift> CODEC = DensityFunctions.singleArgumentCodec(DensityFunction.NoiseHolder.CODEC, DensityFunctions.Shift::new, DensityFunctions.Shift::offsetNoise);

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return this.compute((double) context.blockX(), (double) context.blockY(), (double) context.blockZ());
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.Shift(visitor.visitNoise(this.offsetNoise)));
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.Shift.CODEC;
        }
    }

    private static record BlendDensity(DensityFunction input) implements DensityFunctions.TransformerWithContext {

        private static final KeyDispatchDataCodec<DensityFunctions.BlendDensity> CODEC = DensityFunctions.<DensityFunctions.BlendDensity>singleFunctionArgumentCodec(DensityFunctions.BlendDensity::new, DensityFunctions.BlendDensity::input);

        @Override
        public double transform(DensityFunction.FunctionContext context, double input) {
            return context.getBlender().blendDensity(context, input);
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.BlendDensity(this.input.mapAll(visitor)));
        }

        @Override
        public double minValue() {
            return Double.NEGATIVE_INFINITY;
        }

        @Override
        public double maxValue() {
            return Double.POSITIVE_INFINITY;
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.BlendDensity.CODEC;
        }
    }

    protected static record Clamp(DensityFunction input, double minValue, double maxValue) implements DensityFunctions.PureTransformer {

        private static final MapCodec<DensityFunctions.Clamp> DATA_CODEC = RecordCodecBuilder.mapCodec((instance) -> {
            return instance.group(DensityFunction.DIRECT_CODEC.fieldOf("input").forGetter(DensityFunctions.Clamp::input), DensityFunctions.NOISE_VALUE_CODEC.fieldOf("min").forGetter(DensityFunctions.Clamp::minValue), DensityFunctions.NOISE_VALUE_CODEC.fieldOf("max").forGetter(DensityFunctions.Clamp::maxValue)).apply(instance, DensityFunctions.Clamp::new);
        });
        public static final KeyDispatchDataCodec<DensityFunctions.Clamp> CODEC = DensityFunctions.<DensityFunctions.Clamp>makeCodec(DensityFunctions.Clamp.DATA_CODEC);

        @Override
        public double transform(double input) {
            return Mth.clamp(input, this.minValue, this.maxValue);
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return new DensityFunctions.Clamp(this.input.mapAll(visitor), this.minValue, this.maxValue);
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.Clamp.CODEC;
        }
    }

    protected static record Mapped(DensityFunctions.Mapped.Type type, DensityFunction input, double minValue, double maxValue) implements DensityFunctions.PureTransformer {

        public static DensityFunctions.Mapped create(DensityFunctions.Mapped.Type type, DensityFunction input) {
            double d0 = input.minValue();
            double d1 = input.maxValue();
            double d2 = transform(type, d0);
            double d3 = transform(type, d1);

            return type == DensityFunctions.Mapped.Type.INVERT ? (d0 < 0.0D && d1 > 0.0D ? new DensityFunctions.Mapped(type, input, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY) : new DensityFunctions.Mapped(type, input, d3, d2)) : (type != DensityFunctions.Mapped.Type.ABS && type != DensityFunctions.Mapped.Type.SQUARE ? new DensityFunctions.Mapped(type, input, d2, d3) : new DensityFunctions.Mapped(type, input, Math.max(0.0D, d0), Math.max(d2, d3)));
        }

        private static double transform(DensityFunctions.Mapped.Type type, double input) {
            double d1;

            switch (type.ordinal()) {
                case 0:
                    d1 = Math.abs(input);
                    break;
                case 1:
                    d1 = input * input;
                    break;
                case 2:
                    d1 = input * input * input;
                    break;
                case 3:
                    d1 = input > 0.0D ? input : input * 0.5D;
                    break;
                case 4:
                    d1 = input > 0.0D ? input : input * 0.25D;
                    break;
                case 5:
                    d1 = 1.0D / input;
                    break;
                case 6:
                    double d2 = Mth.clamp(input, -1.0D, 1.0D);

                    d1 = d2 / 2.0D - d2 * d2 * d2 / 24.0D;
                    break;
                default:
                    throw new MatchException((String) null, (Throwable) null);
            }

            return d1;
        }

        @Override
        public double transform(double input) {
            return transform(this.type, input);
        }

        @Override
        public DensityFunctions.Mapped mapAll(DensityFunction.Visitor visitor) {
            return create(this.type, this.input.mapAll(visitor));
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return this.type.codec;
        }

        static enum Type implements StringRepresentable {

            ABS("abs"), SQUARE("square"), CUBE("cube"), HALF_NEGATIVE("half_negative"), QUARTER_NEGATIVE("quarter_negative"), INVERT("invert"), SQUEEZE("squeeze");

            private final String name;
            private final KeyDispatchDataCodec<DensityFunctions.Mapped> codec = DensityFunctions.<DensityFunctions.Mapped>singleFunctionArgumentCodec((densityfunction) -> {
                return DensityFunctions.Mapped.create(this, densityfunction);
            }, DensityFunctions.Mapped::input);

            private Type(String name) {
                this.name = name;
            }

            @Override
            public String getSerializedName() {
                return this.name;
            }
        }
    }

    interface TwoArgumentSimpleFunction extends DensityFunction {

        Logger LOGGER = LogUtils.getLogger();

        static DensityFunctions.TwoArgumentSimpleFunction create(DensityFunctions.TwoArgumentSimpleFunction.Type type, DensityFunction argument1, DensityFunction argument2) {
            double d0 = argument1.minValue();
            double d1 = argument2.minValue();
            double d2 = argument1.maxValue();
            double d3 = argument2.maxValue();

            if (type == DensityFunctions.TwoArgumentSimpleFunction.Type.MIN || type == DensityFunctions.TwoArgumentSimpleFunction.Type.MAX) {
                boolean flag = d0 >= d3;
                boolean flag1 = d1 >= d2;

                if (flag || flag1) {
                    DensityFunctions.TwoArgumentSimpleFunction.LOGGER.warn("Creating a {} function between two non-overlapping inputs: {} and {}", new Object[]{type, argument1, argument2});
                }
            }

            double d4;

            switch (type.ordinal()) {
                case 0:
                    d4 = d0 + d1;
                    break;
                case 1:
                    d4 = d0 > 0.0D && d1 > 0.0D ? d0 * d1 : (d2 < 0.0D && d3 < 0.0D ? d2 * d3 : Math.min(d0 * d3, d2 * d1));
                    break;
                case 2:
                    d4 = Math.min(d0, d1);
                    break;
                case 3:
                    d4 = Math.max(d0, d1);
                    break;
                default:
                    throw new MatchException((String) null, (Throwable) null);
            }

            double d5 = d4;

            switch (type.ordinal()) {
                case 0:
                    d4 = d2 + d3;
                    break;
                case 1:
                    d4 = d0 > 0.0D && d1 > 0.0D ? d2 * d3 : (d2 < 0.0D && d3 < 0.0D ? d0 * d1 : Math.max(d0 * d1, d2 * d3));
                    break;
                case 2:
                    d4 = Math.min(d2, d3);
                    break;
                case 3:
                    d4 = Math.max(d2, d3);
                    break;
                default:
                    throw new MatchException((String) null, (Throwable) null);
            }

            double d6 = d4;

            if (type == DensityFunctions.TwoArgumentSimpleFunction.Type.MUL || type == DensityFunctions.TwoArgumentSimpleFunction.Type.ADD) {
                if (argument1 instanceof DensityFunctions.Constant) {
                    DensityFunctions.Constant densityfunctions_constant = (DensityFunctions.Constant) argument1;

                    return new DensityFunctions.MulOrAdd(type == DensityFunctions.TwoArgumentSimpleFunction.Type.ADD ? DensityFunctions.MulOrAdd.Type.ADD : DensityFunctions.MulOrAdd.Type.MUL, argument2, d5, d6, densityfunctions_constant.value);
                }

                if (argument2 instanceof DensityFunctions.Constant) {
                    DensityFunctions.Constant densityfunctions_constant1 = (DensityFunctions.Constant) argument2;

                    return new DensityFunctions.MulOrAdd(type == DensityFunctions.TwoArgumentSimpleFunction.Type.ADD ? DensityFunctions.MulOrAdd.Type.ADD : DensityFunctions.MulOrAdd.Type.MUL, argument1, d5, d6, densityfunctions_constant1.value);
                }
            }

            return new DensityFunctions.Ap2(type, argument1, argument2, d5, d6);
        }

        DensityFunctions.TwoArgumentSimpleFunction.Type type();

        DensityFunction argument1();

        DensityFunction argument2();

        @Override
        default KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return this.type().codec;
        }

        public static enum Type implements StringRepresentable {

            ADD("add"), MUL("mul"), MIN("min"), MAX("max");

            private final KeyDispatchDataCodec<DensityFunctions.TwoArgumentSimpleFunction> codec = DensityFunctions.<DensityFunctions.TwoArgumentSimpleFunction>doubleFunctionArgumentCodec((densityfunction, densityfunction1) -> {
                return DensityFunctions.TwoArgumentSimpleFunction.create(this, densityfunction, densityfunction1);
            }, DensityFunctions.TwoArgumentSimpleFunction::argument1, DensityFunctions.TwoArgumentSimpleFunction::argument2);
            private final String name;

            private Type(String name) {
                this.name = name;
            }

            @Override
            public String getSerializedName() {
                return this.name;
            }
        }
    }

    private static record MulOrAdd(DensityFunctions.MulOrAdd.Type specificType, DensityFunction input, double minValue, double maxValue, double argument) implements DensityFunctions.TwoArgumentSimpleFunction, DensityFunctions.PureTransformer {

        @Override
        public DensityFunctions.TwoArgumentSimpleFunction.Type type() {
            return this.specificType == DensityFunctions.MulOrAdd.Type.MUL ? DensityFunctions.TwoArgumentSimpleFunction.Type.MUL : DensityFunctions.TwoArgumentSimpleFunction.Type.ADD;
        }

        @Override
        public DensityFunction argument1() {
            return DensityFunctions.constant(this.argument);
        }

        @Override
        public DensityFunction argument2() {
            return this.input;
        }

        @Override
        public double transform(double input) {
            double d1;

            switch (this.specificType.ordinal()) {
                case 0:
                    d1 = input * this.argument;
                    break;
                case 1:
                    d1 = input + this.argument;
                    break;
                default:
                    throw new MatchException((String) null, (Throwable) null);
            }

            return d1;
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            DensityFunction densityfunction = this.input.mapAll(visitor);
            double d0 = densityfunction.minValue();
            double d1 = densityfunction.maxValue();
            double d2;
            double d3;

            if (this.specificType == DensityFunctions.MulOrAdd.Type.ADD) {
                d2 = d0 + this.argument;
                d3 = d1 + this.argument;
            } else if (this.argument >= 0.0D) {
                d2 = d0 * this.argument;
                d3 = d1 * this.argument;
            } else {
                d2 = d1 * this.argument;
                d3 = d0 * this.argument;
            }

            return new DensityFunctions.MulOrAdd(this.specificType, densityfunction, d2, d3, this.argument);
        }

        static enum Type {

            MUL, ADD;

            private Type() {}
        }
    }

    private static record Ap2(DensityFunctions.TwoArgumentSimpleFunction.Type type, DensityFunction argument1, DensityFunction argument2, double minValue, double maxValue) implements DensityFunctions.TwoArgumentSimpleFunction {

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            double d0 = this.argument1.compute(context);
            double d1;

            switch (this.type.ordinal()) {
                case 0:
                    d1 = d0 + this.argument2.compute(context);
                    break;
                case 1:
                    d1 = d0 == 0.0D ? 0.0D : d0 * this.argument2.compute(context);
                    break;
                case 2:
                    d1 = d0 < this.argument2.minValue() ? d0 : Math.min(d0, this.argument2.compute(context));
                    break;
                case 3:
                    d1 = d0 > this.argument2.maxValue() ? d0 : Math.max(d0, this.argument2.compute(context));
                    break;
                default:
                    throw new MatchException((String) null, (Throwable) null);
            }

            return d1;
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            this.argument1.fillArray(output, contextProvider);
            switch (this.type.ordinal()) {
                case 0:
                    double[] adouble1 = new double[output.length];

                    this.argument2.fillArray(adouble1, contextProvider);

                    for (int i = 0; i < output.length; ++i) {
                        output[i] += adouble1[i];
                    }
                    break;
                case 1:
                    for (int j = 0; j < output.length; ++j) {
                        double d0 = output[j];

                        output[j] = d0 == 0.0D ? 0.0D : d0 * this.argument2.compute(contextProvider.forIndex(j));
                    }
                    break;
                case 2:
                    double d1 = this.argument2.minValue();

                    for (int k = 0; k < output.length; ++k) {
                        double d2 = output[k];

                        output[k] = d2 < d1 ? d2 : Math.min(d2, this.argument2.compute(contextProvider.forIndex(k)));
                    }
                    break;
                case 3:
                    double d3 = this.argument2.maxValue();

                    for (int l = 0; l < output.length; ++l) {
                        double d4 = output[l];

                        output[l] = d4 > d3 ? d4 : Math.max(d4, this.argument2.compute(contextProvider.forIndex(l)));
                    }
            }

        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(DensityFunctions.TwoArgumentSimpleFunction.create(this.type, this.argument1.mapAll(visitor), this.argument2.mapAll(visitor)));
        }
    }

    public static record Spline(CubicSpline<DensityFunctions.Spline.Point, DensityFunctions.Spline.Coordinate> spline) implements DensityFunction {

        private static final Codec<CubicSpline<DensityFunctions.Spline.Point, DensityFunctions.Spline.Coordinate>> SPLINE_CODEC = CubicSpline.codec(DensityFunctions.Spline.Coordinate.CODEC);
        private static final MapCodec<DensityFunctions.Spline> DATA_CODEC = DensityFunctions.Spline.SPLINE_CODEC.fieldOf("spline").xmap(DensityFunctions.Spline::new, DensityFunctions.Spline::spline);
        public static final KeyDispatchDataCodec<DensityFunctions.Spline> CODEC = DensityFunctions.<DensityFunctions.Spline>makeCodec(DensityFunctions.Spline.DATA_CODEC);

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return (double) this.spline.apply(new DensityFunctions.Spline.Point(context));
        }

        @Override
        public double minValue() {
            return (double) this.spline.minValue();
        }

        @Override
        public double maxValue() {
            return (double) this.spline.maxValue();
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            contextProvider.fillAllDirectly(output, this);
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.Spline(this.spline.mapAll((densityfunctions_spline_coordinate) -> {
                return densityfunctions_spline_coordinate.mapAll(visitor);
            })));
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.Spline.CODEC;
        }

        public static record Coordinate(Holder<DensityFunction> function) implements BoundedFloatFunction<DensityFunctions.Spline.Point> {

            public static final Codec<DensityFunctions.Spline.Coordinate> CODEC = DensityFunction.CODEC.xmap(DensityFunctions.Spline.Coordinate::new, DensityFunctions.Spline.Coordinate::function);

            public String toString() {
                Optional<ResourceKey<DensityFunction>> optional = this.function.unwrapKey();

                if (optional.isPresent()) {
                    ResourceKey<DensityFunction> resourcekey = (ResourceKey) optional.get();

                    if (resourcekey == NoiseRouterData.CONTINENTS) {
                        return "continents";
                    }

                    if (resourcekey == NoiseRouterData.EROSION) {
                        return "erosion";
                    }

                    if (resourcekey == NoiseRouterData.RIDGES) {
                        return "weirdness";
                    }

                    if (resourcekey == NoiseRouterData.RIDGES_FOLDED) {
                        return "ridges";
                    }
                }

                return "Coordinate[" + String.valueOf(this.function) + "]";
            }

            public float apply(DensityFunctions.Spline.Point point) {
                return (float) ((DensityFunction) this.function.value()).compute(point.context());
            }

            @Override
            public float minValue() {
                return this.function.isBound() ? (float) ((DensityFunction) this.function.value()).minValue() : Float.NEGATIVE_INFINITY;
            }

            @Override
            public float maxValue() {
                return this.function.isBound() ? (float) ((DensityFunction) this.function.value()).maxValue() : Float.POSITIVE_INFINITY;
            }

            public DensityFunctions.Spline.Coordinate mapAll(DensityFunction.Visitor visitor) {
                return new DensityFunctions.Spline.Coordinate(new Holder.Direct(((DensityFunction) this.function.value()).mapAll(visitor)));
            }
        }

        public static record Point(DensityFunction.FunctionContext context) {

        }
    }

    private static record Constant(double value) implements DensityFunction.SimpleFunction {

        private static final KeyDispatchDataCodec<DensityFunctions.Constant> CODEC = DensityFunctions.singleArgumentCodec(DensityFunctions.NOISE_VALUE_CODEC, DensityFunctions.Constant::new, DensityFunctions.Constant::value);
        private static final DensityFunctions.Constant ZERO = new DensityFunctions.Constant(0.0D);

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return this.value;
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            Arrays.fill(output, this.value);
        }

        @Override
        public double minValue() {
            return this.value;
        }

        @Override
        public double maxValue() {
            return this.value;
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.Constant.CODEC;
        }
    }

    private static record YClampedGradient(int fromY, int toY, double fromValue, double toValue) implements DensityFunction.SimpleFunction {

        private static final MapCodec<DensityFunctions.YClampedGradient> DATA_CODEC = RecordCodecBuilder.mapCodec((instance) -> {
            return instance.group(Codec.intRange(DimensionType.MIN_Y * 2, DimensionType.MAX_Y * 2).fieldOf("from_y").forGetter(DensityFunctions.YClampedGradient::fromY), Codec.intRange(DimensionType.MIN_Y * 2, DimensionType.MAX_Y * 2).fieldOf("to_y").forGetter(DensityFunctions.YClampedGradient::toY), DensityFunctions.NOISE_VALUE_CODEC.fieldOf("from_value").forGetter(DensityFunctions.YClampedGradient::fromValue), DensityFunctions.NOISE_VALUE_CODEC.fieldOf("to_value").forGetter(DensityFunctions.YClampedGradient::toValue)).apply(instance, DensityFunctions.YClampedGradient::new);
        });
        public static final KeyDispatchDataCodec<DensityFunctions.YClampedGradient> CODEC = DensityFunctions.<DensityFunctions.YClampedGradient>makeCodec(DensityFunctions.YClampedGradient.DATA_CODEC);

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            return Mth.clampedMap((double) context.blockY(), (double) this.fromY, (double) this.toY, this.fromValue, this.toValue);
        }

        @Override
        public double minValue() {
            return Math.min(this.fromValue, this.toValue);
        }

        @Override
        public double maxValue() {
            return Math.max(this.fromValue, this.toValue);
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.YClampedGradient.CODEC;
        }
    }

    private static record FindTopSurface(DensityFunction density, DensityFunction upperBound, int lowerBound, int cellHeight) implements DensityFunction {

        private static final MapCodec<DensityFunctions.FindTopSurface> DATA_CODEC = RecordCodecBuilder.mapCodec((instance) -> {
            return instance.group(DensityFunction.HOLDER_HELPER_CODEC.fieldOf("density").forGetter(DensityFunctions.FindTopSurface::density), DensityFunction.HOLDER_HELPER_CODEC.fieldOf("upper_bound").forGetter(DensityFunctions.FindTopSurface::upperBound), Codec.intRange(DimensionType.MIN_Y * 2, DimensionType.MAX_Y * 2).fieldOf("lower_bound").forGetter(DensityFunctions.FindTopSurface::lowerBound), ExtraCodecs.POSITIVE_INT.fieldOf("cell_height").forGetter(DensityFunctions.FindTopSurface::cellHeight)).apply(instance, DensityFunctions.FindTopSurface::new);
        });
        public static final KeyDispatchDataCodec<DensityFunctions.FindTopSurface> CODEC = DensityFunctions.<DensityFunctions.FindTopSurface>makeCodec(DensityFunctions.FindTopSurface.DATA_CODEC);

        @Override
        public double compute(DensityFunction.FunctionContext context) {
            int i = Mth.floor(this.upperBound.compute(context) / (double) this.cellHeight) * this.cellHeight;

            if (i <= this.lowerBound) {
                return (double) this.lowerBound;
            } else {
                for (int j = i; j >= this.lowerBound; j -= this.cellHeight) {
                    if (this.density.compute(new DensityFunction.SinglePointContext(context.blockX(), j, context.blockZ())) > 0.0D) {
                        return (double) j;
                    }
                }

                return (double) this.lowerBound;
            }
        }

        @Override
        public void fillArray(double[] output, DensityFunction.ContextProvider contextProvider) {
            contextProvider.fillAllDirectly(output, this);
        }

        @Override
        public DensityFunction mapAll(DensityFunction.Visitor visitor) {
            return visitor.apply(new DensityFunctions.FindTopSurface(this.density.mapAll(visitor), this.upperBound.mapAll(visitor), this.lowerBound, this.cellHeight));
        }

        @Override
        public double minValue() {
            return (double) this.lowerBound;
        }

        @Override
        public double maxValue() {
            return Math.max((double) this.lowerBound, this.upperBound.maxValue());
        }

        @Override
        public KeyDispatchDataCodec<? extends DensityFunction> codec() {
            return DensityFunctions.FindTopSurface.CODEC;
        }
    }
}
